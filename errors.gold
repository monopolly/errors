package errors

import (
	"fmt"
	"path/filepath"
	"runtime"
	"strconv"
	"time"

	"github.com/monopolly/jsons"
)

const (
	fid      = "id"
	fcode    = "code"
	fcomment = "comment"
	ftime    = "time"
	fsource  = "source"
	fref     = "ref"
	ftrace   = "trace"
)

func New(code int, id string, comment ...interface{}) (a E) {
	switch len(comment) > 0 {
	case true:
		return []byte(fmt.Sprintf(`{"code":%d,"id":"%s","time":%d,"comment":"%v"}`, code, id, time.Now().Unix(), comment[0]))
	case false:
		return []byte(fmt.Sprintf(`{"code":%d,"id":"%s","time":%d}`, code, id, time.Now().Unix()))
	}
	return
}

type E []byte

func (a *E) Set(k string, v interface{}) *E {
	(*a) = jsons.Set((*a), k, v)
	return a
}

func (a *E) Time() int64 {
	return jsons.Int64((*a), ftime)
}

func (a *E) ID() string {
	return jsons.String((*a), fid)
}

func (a *E) Code() int {
	return jsons.Int((*a), fcode)
}

func (a *E) Comment() string {
	return jsons.String((*a), fcomment)
}

func (a *E) Source() string {
	return jsons.String((*a), fsource)
}

func (a *E) Refs() string {
	return jsons.String((*a), fref)
}

/* type E struct {
	ID      string `json:"id,omitempty" msg:"id,omitempty"`
	Comment string `json:"comment,omitempty" msg:"comment,omitempty"`
	Time    int64  `json:"time,omitempty" msg:"time,omitempty"` //nano
	Code    int    `json:"code,omitempty" msg:"code,omitempty"`
	Source  string `json:"source,omitempty" msg:"source,omitempty"`
	Ref     string `json:"refs,omitempty" msg:"refs,omitempty"`
} */

//сохраняет номер строки кода откуда вызвана ошибка
func (e *E) X() *E {
	function, file, line, _ := runtime.Caller(1)
	_, file = filepath.Split(file)
	e.Set(fsource, fmt.Sprintf("%s %s:%d", runtime.FuncForPC(function).Name(), file, line))
	return e
}

func (e *E) TimeFormat(format string) string {
	return time.Unix(e.Time(), 0).Format(format)
}

func (e *E) GetTime() time.Time {
	return time.Unix(e.Time(), 0)
}

func (e *E) SetCode(code int) *E {
	return e.Set(fcode, code)
}

type trace struct {
	e    *E
	list map[string]interface{}
}

func (a *E) Trace(key string, value interface{}) *trace {
	n := new(trace)
	n.list = make(map[string]interface{})
	n.list["time"] = time.Now().Unix()
	n.list[key] = value
	return n
}

func (a *trace) Trace(key string, value interface{}) *trace {
	a.list[key] = value
	return a
}

func (a *trace) Done() *E {

	b := jsons.Create()
	for k, v := range a.list {
		b.Add(k, v)
	}

	//a.e.s
	//jsons.ArrayString((*a), ftrace)
	//a.e.Set(ftrace,
	//= jsons.Set((*a), ftrace, append())
	return a.e
}

func itos(x interface{}) string {
	switch x.(type) {
	case int:
		return strconv.Itoa(x.(int))
	case int8:
		return strconv.Itoa(int(x.(int8)))
	case int16:
		return strconv.Itoa(int(x.(int16)))
	case int32:
		return strconv.Itoa(int(x.(int32)))
	case int64:
		return strconv.Itoa(int(x.(int64)))
	case uint:
		return strconv.Itoa(int(x.(uint)))
	case uint8:
		return strconv.Itoa(int(x.(uint8)))
	case uint16:
		return strconv.Itoa(int(x.(uint16)))
	case uint32:
		return strconv.Itoa(int(x.(uint32)))
	case uint64:
		return strconv.Itoa(int(x.(uint64)))
	case string:
		return x.(string)
	case []byte:
		return string(x.([]byte))
	case bool:
		switch x.(bool) {
		case true:
			return "true"
		default:
			return "false"
		}
	case error:
		return x.(error).Error()
	default:
		return fmt.Sprintf("%v", x)
	}
}
